# 균형 트리 (Balanced Tree)

## 1. 균형 트리란?
![image](https://github.com/user-attachments/assets/6725d13e-8e98-4909-bee5-a695f7fd9246)

균형 트리(Balanced Tree)는 트리 구조의 일종으로, 각 노드의 자식 트리들의 높이 차이가 일정 범위 내에 있는 트리입니다. 즉, 트리의 균형을 유지하여 탐색, 삽입, 삭제 등의 연산이 최적의 시간 복잡도에서 수행될 수 있도록 보장합니다.
균형 트리의 중요성은 **효율적인 데이터 접근과 연산**에 있습니다. 비균형 트리는 특정 연산에서 시간 복잡도가 O(n)에 달할 수 있지만, 균형 트리는 최악의 경우에도 O(log n)의 시간 복잡도를 보장합니다. 이는 특히 **대규모 데이터 처리**에서 성능을 크게 향상시킬 수 있습니다. 데이터베이스의 인덱스가 가장 좋은 예시입니다.

## 2. 데이터베이스의 인덱스
![image](https://github.com/user-attachments/assets/0dd95df1-4ac8-4cbb-b4e5-bfb5c5b88e67)
균형 트리는 데이터베이스에서 인덱스 구조로 자주 사용됩니다. 데이터베이스에서 효율적인 검색, 삽입, 삭제 작업을 위해 트리 구조를 이용하며, 균형 트리는 트리의 깊이를 최소화하여 빠른 데이터 접근을 가능하게 합니다. MySQL에서 B트리(B-Tree)를 인텍스 테이블을 만들어 관리하는데 사용됩니다. MySQL의 InnoDB 스토리지 엔진은 기본적으로 B+트리를 사용하며 B-Tree 작동 원리와 구조에서 차이가 있습니다.

## 3. B-Tree

![image](https://github.com/user-attachments/assets/3d07123e-db9b-4189-afb8-8520e983362a)
B-Tree는 기본적으로 루트 노드, 내부 노드, 리프 노드로 구분됩니다. 이중에 내부노드와 리프 노드 모드 데이터를 저장합니다. 각 노드에서 리프 노드는 별도 연결을 포함하지 않습니다. 따라서 검색의 경우 데이터가 내부 노드에 있을 때 더 빨리 검색할 수 있습니다.

### B-Tree 구현
#### 1. BTree.java
해당 인터페이스는 B-Tree와 B+Tree 모두에 대해 공통 기능을 적용하기 위한 인터페이스로 구성됩니다. 기본적으로 데이터 검색, 범위 검색과 데이터 추가, 트리 출력의 4 가지 기능 구현을 필요로 합니다.
```java
import java.util.ArrayList;

public interface BTree {	
	public ArrayList<Integer> print();
	public Integer search(int key);
	public ArrayList<Integer> search(int start,int end);
	public void add(int key);
}
```

#### 2. BMTree.java
BMTree는 B-Tree에 대한 구현입니다. 인터페이스로부터 받아온 기능들을 직접 구현합니다.
<details>
<summary>전체 코드</summary>
  
```java
public class BMTree implements BTree {
	private Node root;
	int degree;
	
	public BMTree(int degree) {
		this.root = null;
		this.degree = degree;
	}
	
  // 전체 트리의 값을 배열로 출력
  @Override
  public ArrayList<Integer> print() {
      ArrayList<Integer> result = new ArrayList<Integer>();
      if (root != null) {
          root.print(result);
      }
      return result;
  }
    
  // 특정 값을 찾는 메서드
  @Override
  public Integer search(int key) {
      if (root != null) {
          return root.search(key);
      }
      return null;
  }
  
  // 범위 검색
  @Override
  public ArrayList<Integer> search(int start, int end) {
      ArrayList<Integer> result = new ArrayList<>();
      if (root != null) {
          root.search(start, end, result);
      }
      return result;
  }
  
  // 값 추가
	public void add(int key) {
        if (root == null) {
            root = new Node(degree, true);
            root.setKey(0, key);
        } else {
            if (root.countKeys() == 2 * degree - 1) {
            	Node node = new Node(degree, false);
            	node.setChild(0,root);
            	node.split(0,root);

                int i = 0;
                if (node.getKey(0) < key) {
                    i++;
                }
                node.getChild(i).insert(key);
                root = node;
            } else {
                root.insert(key);
            }
        }
    }
  // Node Class
}
```
</details>

<details>
<summary>B-트리 <code>add</code> 메소드 설명</summary>

```java
// 값 추가
  public void add(int key) {
      // 루트 노드가 비어있는 경우
      if (root == null) {
          // 새 노드를 생성하고 루트로 설정
          root = new Node(degree, true);
          // 루트 노드에 첫 번째 키를 설정
          root.setKey(0, key);
      } else {
          // 루트 노드가 가득 찬 경우
          if (root.countKeys() == 2 * degree - 1) {
              // 새로운 내부 노드 생성
              Node node = new Node(degree, false);
              // 새로운 노드의 첫 번째 자식으로 기존 루트 설정
              node.setChild(0, root);
              // 루트 노드를 분할하여 새로운 내부 노드로 승격
              node.split(0, root);
  
              // 삽입할 키가 어느 자식 노드에 들어갈지 결정
              int i = 0;
              if (node.getKey(0) < key) {
                  i++; // 키 값이 새 루트 노드의 첫 번째 키보다 크면, 두 번째 자식으로 삽입
              }
              // 해당 자식 노드에 값을 삽입
              node.getChild(i).insert(key);
              // 새로운 노드를 루트로 설정
              root = node;
          } else {
              // 루트 노드에 값 삽입
              root.insert(key);
          }
      }
  }
```
**설명**
1. **루트 노드가 비어 있는 경우**:
   - 트리가 비어 있을 경우, 새로 루트 노드를 생성하고, 해당 노드에 첫 번째 `key` 값을 저장합니다.
   - 이 과정은 트리가 처음 시작되는 경우에 해당합니다.
2. **루트 노드가 가득 찬 경우**:
   - 루트 노드가 이미 꽉 차 있는 경우, 새로운 **내부 노드**를 생성하여 기존 루트 노드를 자식으로 설정합니다.
   - 새로운 내부 노드는 루트 노드를 분할(`split`)하여 키 값을 상위 노드로 승격시킵니다.
   - 분할 후, 삽입할 `key` 값을 적절한 자식 노드에 삽입하기 위해 자식 노드를 선택합니다. 이때, 새로운 루트 노드의 키 값을 기준으로 `key`가 삽입될 위치를 결정합니다.
3. **값 삽입**:
   - 선택된 자식 노드에 `key` 값을 삽입합니다.
   - 삽입 후, 새로운 노드를 루트로 설정하여 트리의 균형을 유지합니다.
4. **루트 노드가 가득 차지 않은 경우**:
   - 만약 루트 노드가 가득 차지 않은 상태라면, 그냥 루트 노드에 `key` 값을 삽입합니다.  
</details>

#### 3. Node Class
Node Class는 BMTree 내부 클래스입니다. 각 노드의 역할을 하면서 차수, 자식 배열과 키 배열 리프 여부를 포함하고 있습니다. 또한 검색과 삽입 분할에 대한 기능도 포함하고 있습니다.
<details>
<summary>전체 코드</summary>
  
```java
  class Node{
    private int degree; // 최소 차수
    private Node[] children; // 자식 노드 배열
    private int[] keys; // 키 배열
    private boolean isLeaf; // 리프 노드 여부
    
    public Node(int degree, boolean isLeaf) {
          this.degree = degree;
          this.isLeaf = isLeaf;
          this.keys = new int[2 * degree - 1];
          this.children = new Node[2 * degree];
      }	
    
    // 출력
    public void print(ArrayList<Integer> arr) {
      int keyCount = countKeys();
      for (int i = 0; i < keyCount; i++) {
              if (!isLeaf) {
                children[i].print(arr);
              }
              arr.add(keys[i]);
          }
          if (!isLeaf) {
            children[keyCount].print(arr);
          }
    }
    
      // 키 검색 기능
      public Integer search(int key) {
          int i = 0;
          while (i < countKeys() && keys[i] < key) i++;
          
          // 검색 결과 반환
          if (i < countKeys() && keys[i] == key) return keys[i]; 
          
          // 리프 노드에 도달했으므로 값이 없음
          if (isLeaf) return null; 
          
          // 자식 노드로 내려감
          return children[i].search(key); 
      }
      
      public void search(int start, int end, ArrayList<Integer> result) {
          int i = 0;
          while (i < countKeys() && keys[i] < start) i++;
          
    
          while (i < countKeys() && keys[i] <= end) {
              if (!isLeaf) children[i].search(start, end, result);            
              result.add(keys[i]);
              i++;
          }
    
          if (!isLeaf) children[i].search(start, end, result);
          
      }
		
    public void insert(int key) {
        int i = countKeys() - 1;  // 마지막 키 인덱스        
        if (isLeaf) {
            // 리프 노드에 삽입할 위치 찾기
            while (i >= 0 && keys[i] > key) {
                keys[i + 1] = keys[i];  // 오른쪽으로 키를 밀기
                i--;
            }
            keys[i + 1] = key;  // 키 삽입
        } else {
            // 자식 노드로 내려가서 삽입
            while (i >= 0 && keys[i] > key) {
                i--;
            }
            i++;  // 자식 노드 인덱스
            
            // 자식 노드가 가득 차 있으면 분리
            if (children[i].countKeys() == 2 * degree - 1) {
                split(i, children[i]);  // 자식 노드 분리
                if (keys[i] < key) {
                    i++;  // 분리 후, 키에 맞는 자식으로 이동
                }
            }
            
            // 적합한 자식 노드로 내려가서 삽입
            children[i].insert(key);
        }
    }
	    
    public void split(int i, Node y) {
        int t = degree;  // 최소 차수
        
        // 새로운 노드 z 생성
        Node z = new Node(degree, y.isLeaf());
        
        // y의 중간 키를 부모 노드로 이동
        for (int j = 0; j < t - 1; j++) {
            z.setKey(j, y.getKey(j + t));
            y.setKey(j + t, 0);  // 원래 노드에서 키 제거
        }
        
        // 자식 노드가 있다면 분리된 자식 노드를 z로 이동
        if (!y.isLeaf()) {
            for (int j = 0; j < t; j++) {
                z.setChild(j, y.getChild(j + t));
                y.setChild(j + t, null);  // 원래 노드에서 자식 제거
            }
        }
    
        // 부모 노드에 새로운 자식과 키 삽입
        for (int j = countKeys(); j >= i + 1; j--) {
            setChild(j + 1, getChild(j));
        }
        setChild(i + 1, z);  // z 자식 추가
        
        for (int j = countKeys() - 1; j >= i; j--) {
            setKey(j + 1, getKey(j));
        }
        setKey(i, y.getKey(t - 1));  // 부모에 중간 키 삽입
        y.setKey(t - 1, 0);  // y에서 중간 키 제거
    }
	    
		public boolean isLeaf() {
			return this.isLeaf;
		}		
		public Node getChild(int i) {
			return this.children[i];
		}		
		public void setChild(int i,Node node) {
			this.children[i] = node;
		}		
		public int getKey(int i) {
			return this.keys[i];
		}		
		public void setKey(int i,int key) {
			this.keys[i] = key;
		}		
    public int countKeys() {
        int count = 0;
        for (int key : keys) { if (key == 0) break; count++; }
        return count;
    }		 
	}
```
</details>

<details>  
<summary>B-트리 <code>insert</code> 메소드 설명</summary>  

```java
// 노드에 키 삽입
public void insert(int key) {
    int i = countKeys() - 1;  // 마지막 키의 인덱스

    // 리프 노드에 삽입
    if (isLeaf) {
        // 삽입할 위치를 찾기 위해 오른쪽으로 이동
        while (i >= 0 && keys[i] > key) {
            keys[i + 1] = keys[i];  // 기존 키를 오른쪽으로 이동
            i--;
        }
        // 새로운 키 삽입
        keys[i + 1] = key;
    } else {
        // 적절한 자식 노드를 찾기 위해 이동
        while (i >= 0 && keys[i] > key) {
            i--;
        }
        i++;  // 자식 노드 인덱스 결정

        // 자식 노드가 가득 찬 경우 분할
        if (children[i].countKeys() == 2 * degree - 1) {
            split(i, children[i]);  // 자식 노드 분할
            if (keys[i] < key) {
                i++;  // 분할 후 오른쪽 자식으로 이동
            }
        }
        // 선택된 자식 노드에 삽입
        children[i].insert(key);
    }
}
```
**설명**
1. **리프 노드 삽입**:  
   - 리프 노드에서 삽입 위치를 찾습니다.  
   - 기존 키를 오른쪽으로 이동시키고, 새로운 키를 해당 위치에 삽입합니다.  
2. **내부 노드 처리**:  
   - 삽입할 키에 맞는 자식 노드를 탐색합니다.  
   - 자식 노드가 가득 찬 경우 `split` 메소드를 호출해 노드를 분할합니다.  
   - 분할 이후, 삽입할 키가 오른쪽 자식으로 이동해야 할 경우 인덱스를 조정합니다.  
3. **재귀적 삽입**:  
   - 선택된 자식 노드로 이동하여 재귀적으로 키를 삽입합니다.  
</details>

<details>
<summary>B-트리 <code>split</code> 메소드 설명</summary>

```java
// 노드 분할
public void split(int i, Node y) {
    int t = degree;  // 최소 차수
    
    // 새로운 노드 z 생성
    Node z = new Node(degree, y.isLeaf());
    
    // y의 중간 키를 부모 노드로 이동
    for (int j = 0; j < t - 1; j++) {
        z.setKey(j, y.getKey(j + t));
        y.setKey(j + t, 0);  // 원래 노드에서 키 제거
    }
    
    // 자식 노드가 있다면 분리된 자식 노드를 z로 이동
    if (!y.isLeaf()) {
        for (int j = 0; j < t; j++) {
            z.setChild(j, y.getChild(j + t));
            y.setChild(j + t, null);  // 원래 노드에서 자식 제거
        }
    }

    // 부모 노드에 새로운 자식과 키 삽입
    for (int j = countKeys(); j >= i + 1; j--) {
        setChild(j + 1, getChild(j));
    }
    setChild(i + 1, z);  // z 자식 추가
    
    for (int j = countKeys() - 1; j >= i; j--) {
        setKey(j + 1, getKey(j));
    }
    setKey(i, y.getKey(t - 1));  // 부모에 중간 키 삽입
    y.setKey(t - 1, 0);  // y에서 중간 키 제거
}
```
**설명**
1. **새로운 노드 생성**:  
   - `split` 메소드는 부모 노드가 자식 노드에서 한 개 이상의 키를 분할하여 새로운 자식 노드를 만들 때 사용됩니다.  
   - `z`라는 새로운 노드를 생성하여 분리된 데이터를 이동합니다.
2. **중간 키 부모로 이동**:  
   - 분할할 때, `y`의 중간 키를 부모 노드로 승격시킵니다.  
   - 이 중간 키는 부모 노드의 자식 포인터와 키 배열에 삽입됩니다.
3. **자식 노드 이동**:  
   - `y`가 자식 노드를 가지고 있다면, 분할된 자식 노드들도 새로운 노드 `z`로 이동합니다.  
   - 자식 노드들에 대한 포인터를 `z`에 설정하고, `y`에서 해당 자식들을 삭제합니다.
4. **부모 노드에 자식 추가**:  
   - 부모 노드에 새로운 자식 노드를 추가하고, 기존 자식 노드들의 포인터를 오른쪽으로 밀어냅니다.
5. **키 이동 및 업데이트**:  
   - 부모 노드에 새로운 키를 추가하고, `y`에서 중간 키를 제거합니다.  
   - 부모 노드가 가득 차지 않도록 삽입된 키들이 올바르게 배치됩니다.
</details>


<details>
<summary>B-트리 <code>search</code> 메소드 설명</summary>

```java
// 키 검색 기능
public Integer search(int key) {
    int i = 0;
    while (i < countKeys() && keys[i] < key) i++;
    
    // 검색 결과 반환
    if (i < countKeys() && keys[i] == key) return keys[i]; 
    
    // 리프 노드에 도달했으므로 값이 없음
    if (isLeaf) return null; 
    
    // 자식 노드로 내려감
    return children[i].search(key); 
}
```
**설명**
1. **키 탐색**:  
   - 먼저, `keys` 배열을 순차적으로 비교하여 `key`를 찾습니다.  
   - `key`가 발견되면 해당 값을 반환합니다.

2. **리프 노드 체크**:  
   - 만약 `key`를 찾지 못했거나 리프 노드에 도달하면 `null`을 반환합니다.

3. **자식 노드로 이동**:  
   - `key`를 찾지 못하면, 적절한 자식 노드로 내려가서 재귀적으로 `search` 메소드를 호출하여 탐색을 계속합니다.
</details>

## 4. 성능 비교

### 데이터 수 1000개

**선형 검색 결과**  
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 0.20       | 0.15       | 0.23       | 0.29       | 0.21       | 0.04       | 0.18       | 0.04       | 0.06       | 0.04        | 0.15     |
| **검색(ms)**           | 1.24       | 0.12       | 0.34       | 0.10       | 0.38       | 0.19       | 0.10       | 0.31       | 0.10       | 0.11        | 0.18     |
| **범위 검색(ms)**     | 5.08       | 0.32       | 1.13       | 0.31       | 0.32       | 0.33       | 0.34       | 0.48       | 0.34       | 0.31        | 0.38     |

**B-트리 실험 결과**  
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 2.09       | 0.24       | 0.81       | 0.70       | 0.15       | 0.16       | 0.22       | 0.25       | 0.15       | 0.15        | 0.33     |
| **검색(ms)**           | 0.48       | 0.60       | 0.61       | 0.20       | 0.09       | 0.20       | 0.10       | 0.13       | 0.16       | 0.13        | 0.16     |
| **범위 검색(ms)**     | 0.03       | 0.01       | 0.01       | 0.00       | 0.00       | 0.00       | 0.00       | 0.00       | 0.00       | 0.00        | 0.01     |

### 데이터 수 5000개

**선형 검색 결과**  
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 0.84       | 0.63       | 0.52       | 0.33       | 0.40       | 0.27       | 0.25       | 0.06       | 0.25       | 0.41        | 0.34     |
| **검색(ms)**           | 12.10      | 7.48       | 3.52       | 5.24       | 4.44       | 3.93       | 6.89       | 7.40       | 6.89       | 9.86        | 6.43     |
| **범위 검색(ms)**     | 0.71       | 2.37       | 1.28       | 0.63       | 1.09       | 0.63       | 2.17       | 2.36       | 2.17       | 4.02        | 2.09     |

**B-트리 실험 결과**  
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 5.08       | 3.83       | 1.99       | 1.76       | 1.59       | 1.38       | 1.29       | 1.15       | 1.15       | 1.98        | 2.07     |
| **검색(ms)**           | 6.29       | 10.56      | 3.52       | 3.49       | 2.45       | 2.11       | 2.05       | 2.25       | 2.25       | 1.98        | 2.72     |
| **범위 검색(ms)**     | 1.28       | 0.12       | 0.38       | 0.34       | 0.25       | 0.23       | 0.44       | 0.26       | 0.44       | 0.21        | 0.32     |

### 데이터 수 10000개

**선형 검색 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 0.84       | 0.63       | 0.52       | 0.33       | 0.40       | 0.27       | 0.25       | 0.06       | 0.25       | 0.41        | 0.34     |
| **검색(ms)**           | 12.10      | 7.48       | 3.52       | 5.24       | 4.44       | 3.93       | 6.89       | 7.40       | 6.89       | 9.86        | 6.43     |
| **범위 검색(ms)**     | 0.71       | 2.37       | 1.28       | 0.63       | 1.09       | 0.63       | 2.17       | 2.36       | 2.17       | 4.02        | 2.09     |

**B-트리 실험 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 5.08       | 3.83       | 1.99       | 1.76       | 1.59       | 1.38       | 1.29       | 1.15       | 1.15       | 1.98        | 2.07     |
| **검색(ms)**           | 6.29       | 10.56      | 3.52       | 3.49       | 2.45       | 2.11       | 2.05       | 2.25       | 2.25       | 1.98        | 2.72     |
| **범위 검색(ms)**     | 1.28       | 0.12       | 0.38       | 0.34       | 0.25       | 0.23       | 0.44       | 0.26       | 0.44       | 0.21        | 0.32     |

### 데이터 수 50000개

**선형 검색 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 17.11      | 2.98       | 3.53       | 1.22       | 0.57       | 0.63       | 1.30       | 0.63       | 0.64       | 0.66        | 3.33     |
| **검색(ms)**           | 297.70     | 210.57     | 197.42     | 205.30     | 251.90     | 279.57     | 305.01     | 256.52     | 254.59     | 302.18      | 255.92   |
| **범위 검색(ms)**     | 0.66       | 2.00       | 0.62       | 0.61       | 0.61       | 0.63       | 0.69       | 0.66       | 0.61       | 0.61        | 0.63     |

**B-트리 실험 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 26.38      | 8.41       | 6.27       | 4.38       | 4.50       | 4.39       | 3.95       | 3.94       | 4.06       | 4.49        | 5.17     |
| **검색(ms)**           | 13.51      | 7.37       | 6.95       | 6.35       | 5.94       | 6.97       | 5.97       | 6.11       | 6.53       | 6.66        | 6.20     |
| **범위 검색(ms)**     | 0.26       | 0.16       | 0.11       | 0.07       | 0.05       | 0.05       | 0.05       | 0.05       | 0.05       | 0.06        | 0.06     |


### 데이터 수 100000개

**Array 실험 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 13.84      | 2.27       | 2.68       | 0.68       | 0.66       | 0.73       | 0.74       | 0.65       | 0.81       | 0.63        | 3.33     |
| **검색(ms)**           | 886.10     | 781.50     | 778.94     | 748.86     | 754.88     | 747.19     | 747.66     | 748.04     | 746.22     | 754.49      | 755.92   |
| **범위 검색(ms)**     | 67.63      | 80.96      | 83.10      | 85.41      | 79.87      | 84.79      | 80.66      | 82.97      | 89.73      | 80.77       | 82.97    |

**B-트리 실험 결과**
| **조건**               | **실험 1** | **실험 2** | **실험 3** | **실험 4** | **실험 5** | **실험 6** | **실험 7** | **실험 8** | **실험 9** | **실험 10** | **평균**  |
|------------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|-------------|----------|
| **삽입(ms)**           | 22.57      | 10.73      | 7.57       | 6.99       | 7.08       | 7.26       | 7.51       | 7.26       | 7.01       | 6.96        | 5.17     |
| **검색(ms)**           | 35.23      | 12.30      | 13.36      | 12.22      | 12.39      | 12.21      | 12.74      | 12.11      | 12.31      | 12.74       | 12.20    |
| **범위 검색(ms)**     | 1.43       | 0.47       | 0.20       | 0.23       | 0.18       | 0.18       | 0.20       | 0.17       | 0.22       | 0.20        | 0.06     |

## 결과 분석
| **데이터 수** | **작업**     | **선형 검색 평균 (ms)** | **B-트리 평균 (ms)** | **성능 향상 (%)** |
|---------------|--------------|------------------------|----------------------|------------------|
| **1000개**    | 삽입         | 0.15                   | 0.33                 | -120%            |
|               | 검색         | 0.18                   | 0.16                 | 11.11%           |
|               | 범위 검색    | 0.38                   | 0.01                 | 97.37%           |
| **5000개**    | 삽입         | 0.34                   | 2.07                 | -508.82%         |
|               | 검색         | 6.43                   | 2.72                 | 57.69%           |
|               | 범위 검색    | 2.09                   | 0.32                 | 84.69%           |
| **10000개**   | 삽입         | 0.83                   | 3.79                 | -355.42%         |
|               | 검색         | 9.83                   | 3.46                 | 64.85%           |
|               | 범위 검색    | 5.01                   | 0.48                 | 90.42%           |
| **50000개**   | 삽입         | 4.75                   | 31.58                | -565.47%         |
|               | 검색         | 48.21                  | 12.64                | 73.80%           |
|               | 범위 검색    | 22.32                  | 2.32                 | 89.58%           |
| **100000개**  | 삽입         | 8.90                   | 73.39                | -727.08%         |
|               | 검색         | 133.03                 | 25.39                | 80.91%           |
|               | 범위 검색    | 45.35                  | 5.01                 | 88.96%           |

1. **삽입 성능**:
   - **선형 검색**은 데이터가 적을 때는 빠른 성능을 보이지만, 데이터가 많아질수록 성능이 급격히 저하됩니다. 특히 **5000개 이상의 데이터**에서 성능 저하가 두드러지며, **10000개 이상**에서는 **B-트리**에 비해 삽입 성능이 상대적으로 우수합니다.
   - **B-트리**는 삽입 성능에서 **선형 검색**보다 더 느리며, 데이터 수가 많을수록 **성능 차이**가 더욱 두드러집니다. **10000개 이상의 데이터**에서는 **B-트리** 삽입 성능이 현저히 느려지며, **선형 검색**보다 성능이 저하됩니다.

2. **검색 성능**:
   - **선형 검색**은 데이터가 적을 때는 나쁘지 않지만, 데이터 수가 많아지면 급격히 성능이 나빠집니다. **10000개 이상** 데이터에서는 **B-트리**에 비해 검색 성능이 **현저히 떨어집니다**.
   - **B-트리**는 대규모 데이터에서도 일정한 검색 성능을 유지하며, **선형 검색**에 비해 월등히 효율적입니다. **10000개 이상의 데이터**에서 **B-트리**가 검색 성능에서 우위를 보입니다.

3. **범위 검색 성능**:
   - **선형 검색**은 범위 검색에서 성능이 매우 낮고, 데이터가 많을수록 성능이 급격히 떨어집니다. 예를 들어, **50000개 이상의 데이터**에서 범위 검색 성능이 **22.32ms**로 급격히 떨어집니다.
   - **B-트리**는 범위 검색에서 **탁월한 성능**을 보이며, 데이터 수가 많아져도 성능 저하가 적습니다. **100000개 이상의 데이터**에서도 범위 검색이 **5.01ms**로 빠르게 수행됩니다.

4. **성능 향상**:
   - **선형 검색**에서 **B-트리**로의 전환은 **모든 데이터 수**에서 성능 향상을 보여줍니다. 특히 데이터 수가 많을수록 **B-트리**의 성능 우위가 더욱 두드러집니다.
   - **선형 검색**은 데이터가 많을수록 성능 저하가 심각하지만, **B-트리**는 대규모 데이터셋에서 성능 향상이 크고 효율적입니다.

## 정리
- **선형 검색**은 작은 데이터셋에서 유용할 수 있으나, 데이터가 많아질수록 성능이 급격히 저하됩니다. 특히 **범위 검색**에서 매우 비효율적입니다.
- **B-트리**는 대규모 데이터에서 뛰어난 성능을 보이며, **검색, 범위 검색**에서 안정적인 성능을 제공합니다. 그러나 **삽입 성능**에서는 **선형 검색**에 비해 성능이 떨어지므로, 삽입 성능이 중요한 경우에는 **선형 검색**이 더 적합할 수 있습니다.
- 대규모 데이터셋에서 **범위 검색**이 중요한 경우, **B-트리**가 성능 면에서 훨씬 우수하며, **B-트리**를 사용하여 성능을 극대화하는 것이 좋습니다. 하지만 **삽입 성능**을 중시하는 경우에는 **선형 검색**이 더 나을 수 있습니다.


